<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js ASCII Point Cloud Viewer</title>
    <style>
        body {
            margin: 0;
        }
        canvas {
            display: block;
        }
        
        body { margin: 0; }
        canvas { display: block; }
        button {
            position: absolute;
            left: 10px;
            top: 10px;
            z-index: 10;
        }
        #complexShapeMarkerBtn {
            top: 50px;
        }
</style>
    </style>
</head>
<body>
    <button id="triangleMarkerBtn">Triangle Marker</button>
    <button id="complexShapeMarkerBtn">Complex Shape Marker</button>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import { MTLLoader } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/loaders/MTLLoader.js';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/loaders/OBJLoader.js';

        let selectedMarkerType = '';

        //scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 0, 100);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        const ambientLight = new THREE.AmbientLight(0xffffff);
        scene.add(ambientLight);
        //var axesHelper = new THREE.AxesHelper(5);
        //scene.add(axesHelper);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xAAAAAA);
        renderer.domElement.addEventListener('click', onDocumentMouseClick, false);
        document.body.appendChild(renderer.domElement);

        //websocket setup
        const socket = new WebSocket('ws://localhost:8765');
        socket.onopen = function(e) {
            console.log("Connection established");
        };

        socket.onmessage = function(event) {
            console.log(`Data received from server: ${event.data}`);
            if (event.data === "new_shape_available") {
                loadShapeFromOBJ("shape objects/shape.obj", "shape objects/shape.mtl");
            }
        };

        //Animate the scene
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        //function to load an ascii file, parse it and add it to the scene
        function loadASCIIPointCloud(url) {
            fetch(url)
                .then(response => response.text())
                .then(text => {

                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    const colors = [];
                    let centroid = new THREE.Vector3(0, 0, 0);
                    let pointCount = 0;

                    const lines = text.split('\n');
                    for (let line of lines) {
                        const parts = line.trim().split(/\s+/);
                        if (parts.length === 3 || parts.length === 6) {
                            //Parse XYZ coordinates
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            const z = parseFloat(parts[2]);

                            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                                vertices.push(x, y, z); //Temporarily store the original coordinates
                                centroid.add(new THREE.Vector3(x, y, z));
                                pointCount++;

                                //Parse RGB colors if available
                                if (parts.length === 6) {
                                    const r = parseInt(parts[3]) / 65535;
                                    const g = parseInt(parts[4]) / 65535;
                                    const b = parseInt(parts[5]) / 65535;
                                    colors.push(r, g, b);
                                } else {
                                    colors.push(0, 0, 1); //Default color: blue
                                }
                            }
                        }
                    }

                    // Calculate the centroid
                    centroid.divideScalar(pointCount);

                    // Adjust each point's position relative to the centroid
                    const adjustedVertices = [];
                    for (let i = 0; i < vertices.length; i += 3) {
                        adjustedVertices.push(vertices[i] - centroid.x);
                        adjustedVertices.push(vertices[i + 1] - centroid.y);
                        adjustedVertices.push(vertices[i + 2] - centroid.z);
                    }

                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(adjustedVertices, 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    const material = new THREE.PointsMaterial({ size: 0.01, vertexColors: true });
                    const pointCloud = new THREE.Points(geometry, material);

                    scene.add(pointCloud);

                    // Set up camera and controls
                    camera.position.set(0, 0, 30);
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                    const controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(0, 0, 0); 
                    controls.update();

                    // Add a grid helper centered at the origin
                    const gridHelper = new THREE.GridHelper(1000, 1000);
                    gridHelper.rotation.x = Math.PI / 2;
                    scene.add(gridHelper);

                    
                });
        }
        //Function to load the shape from OBJ and MTL files
        function loadShapeFromOBJ(objPath, mtlPath) {
            new MTLLoader()
                .load(mtlPath, function (materials) {
                    materials.preload();
                    new OBJLoader()
                        .setMaterials(materials)
                        .load(objPath, 
                            function (object) {
                                scene.add(object);
                                object.position.set(0, 0, 1); 
                                object.scale.set(1, 1, 1); 
                            },
                            function (xhr) {
                                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                            },
                            function (error) {
                                console.error('An error happened', error);
                            });
                }, 
                function (xhr) {
                    console.log('MTL ' + (xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('An error happened while loading MTL', error);
                });
        }

        // Add event listeners for buttons
        document.getElementById('triangleMarkerBtn').addEventListener('click', () => {
            selectedMarkerType = 'triangle_marker';
            console.log('Triangle Marker selected');
        });

        document.getElementById('complexShapeMarkerBtn').addEventListener('click', () => {
            selectedMarkerType = 'complex_marker';
            console.log('Complex Shape Marker selected');
        });

        //function to handle mouse clicks
        function onDocumentMouseClick(event) {
            event.preventDefault();

            //Calculate mouse position 
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

            //Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            //Assume a plane at z = 0 
            const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const targetPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(planeZ, targetPoint);

            console.log("Clicked coordinates in 3D space:", targetPoint);

            //Send the coordinates to the WebSocket server
            if (targetPoint) {
                let message = {
                    x: targetPoint.x, 
                    y: targetPoint.y, 
                    z: targetPoint.z,
                    type: selectedMarkerType  // Include the selected marker type
                };
                socket.send(JSON.stringify({ message}));
            }
        }

        let point_cloud_path = 'pointclouds/pointcloud.txt'
        loadShapeFromOBJ("shape objects/shape.obj", "shape objects/shape.mtl")
        loadASCIIPointCloud(point_cloud_path);

    </script>
</body>

</html>